---
title: (挖个坑)锁是怎么实现的？
date: 2021-05-15 20:35:21
tags: 底层原理
index_img: /img/gopher1.jpg
---



### 为什么需要锁

​		最开始接触锁，是在操作系统这门课中。锁是为了解决临界区冲突而产生的，通过对共享资源加锁，保证对其操作的原子性和独占性。比如两个进程要操作同一个变量，操作过程如下

​		1.读取变量

​		2.变量值加一

​		3.写回

如果变量a初始值为3，进程一开始对他进行操作，读到的变量值是3，然后对他加一得到结果为4，同时准备写回，但写回前又有一进程开始对变量进行操作，因为进程一的结果还没写回，他读到的变量值也是3，计算得到4，也准备把4写回变量，最终在两个进程分别操作后，a的结果还是4。但如果他们顺序执行，应该得到的结果是5。

为了避免这一问题，我们可以对变量a进行加锁，这样就可以保证对a的操作是原子的。

​		1.获取锁		

​		2.读取变量

​		3.变量值加一

​		4.写回

​		5.释放锁

在同一时刻只有一个进程能获取到锁，所以就保证了2-4的步骤只能有一个进程在执行。

### 如何保证锁本身的原子性

​		获取锁的过程：

​		1.读取锁变量

​		2.判断是否空闲

​		3.若空闲，获取锁，否则退出

​		4.修改锁变量

​		5.退出



​		前面说到锁主要为了解决临界区的冲突问题，那么锁本身就必须具备原子性。如果两个进程并发获取一个锁，第一个进程判断锁是空闲的，于是可以获取他，并正在修改锁变量，而第二个进程在这时开始读取锁变量并判断出他是空闲的，因此也可以进行后续的操作，这样会导致两个进程都获取了这个锁。所以获取锁这一过程必须保证是原子的，而锁本身实际上也就是一个普通变量而已，那么他的原子性要如何保证呢？



​		在单CPU的机器上，由于不存在并行的问题，只需要在获取锁前**关中断**，在关中断后进行的操作不会被打断，因此可以认为是原子的，在完成操作后再恢复中断即可。

​		而在多CPU的机器中问题就比较复杂了，为了实现原子性，在计算机中提供了一些指令，比如**TestAndSet**，可以直接对一个变量进行判断并赋值的原子操作。他们的实现原理是把多步的操作合并在一起，作为一条执行，而CPU在执行一条指令时是不可以被打断的，这样原子性就得到了。



### 更多的锁

​		在有了底层提供的原子性这一基础，我们还可以实现出更多机制更丰富的锁。









